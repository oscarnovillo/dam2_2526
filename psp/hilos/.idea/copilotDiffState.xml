<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/blocking_queue/MainBlockingQueue.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/blocking_queue/MainBlockingQueue.java" />
              <option name="updatedContent" value="package blocking_queue;&#10;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Demostración de BlockingQueue en Java&#10; * &#10; * Una BlockingQueue es una cola thread-safe que:&#10; * 1. Bloquea el hilo cuando intentas extraer de una cola vacía&#10; * 2. Bloquea el hilo cuando intentas insertar en una cola llena&#10; * 3. Es perfecta para el patrón Productor-Consumidor&#10; */&#10;public class MainBlockingQueue {&#10;    &#10;    // Cola con capacidad limitada de 5 elementos&#10;    private static final BlockingQueue&lt;String&gt; cola = new ArrayBlockingQueue&lt;&gt;(5);&#10;    &#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;=== DEMOSTRACIÓN DE BLOCKING QUEUE ===\n&quot;);&#10;        &#10;        // Crear hilos productores&#10;        Thread productor1 = new Thread(new Productor(&quot;Productor-1&quot;), &quot;Productor-1&quot;);&#10;        Thread productor2 = new Thread(new Productor(&quot;Productor-2&quot;), &quot;Productor-2&quot;);&#10;        &#10;        // Crear hilos consumidores&#10;        Thread consumidor1 = new Thread(new Consumidor(&quot;Consumidor-1&quot;), &quot;Consumidor-1&quot;);&#10;        Thread consumidor2 = new Thread(new Consumidor(&quot;Consumidor-2&quot;), &quot;Consumidor-2&quot;);&#10;        &#10;        // Iniciar todos los hilos&#10;        productor1.start();&#10;        productor2.start();&#10;        consumidor1.start();&#10;        consumidor2.start();&#10;        &#10;        try {&#10;            // Esperar 10 segundos y luego terminar&#10;            Thread.sleep(10000);&#10;            &#10;            // Interrumpir todos los hilos&#10;            productor1.interrupt();&#10;            productor2.interrupt();&#10;            consumidor1.interrupt();&#10;            consumidor2.interrupt();&#10;            &#10;            System.out.println(&quot;\n=== PROGRAMA TERMINADO ===&quot;);&#10;            &#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Clase Productor - Añade elementos a la cola&#10;     */&#10;    static class Productor implements Runnable {&#10;        private final String nombre;&#10;        private int contador = 1;&#10;        &#10;        public Productor(String nombre) {&#10;            this.nombre = nombre;&#10;        }&#10;        &#10;        @Override&#10;        public void run() {&#10;            try {&#10;                while (!Thread.currentThread().isInterrupted()) {&#10;                    String mensaje = nombre + &quot;-Mensaje-&quot; + contador++;&#10;                    &#10;                    System.out.println(&quot; &quot; + nombre + &quot; intentando añadir: &quot; + mensaje + &#10;                                     &quot; (Tamaño cola: &quot; + cola.size() + &quot;)&quot;);&#10;                    &#10;                    // put() bloquea si la cola está llena&#10;                    cola.put(mensaje);&#10;                    &#10;                    System.out.println(&quot;✅ &quot; + nombre + &quot; añadió: &quot; + mensaje + &#10;                                     &quot; (Tamaño cola: &quot; + cola.size() + &quot;)&quot;);&#10;                    &#10;                    // Pausa entre producciones&#10;                    Thread.sleep(1000);&#10;                }&#10;            } catch (InterruptedException e) {&#10;                System.out.println(&quot; &quot; + nombre + &quot; interrumpido&quot;);&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Clase Consumidor - Extrae elementos de la cola&#10;     */&#10;    static class Consumidor implements Runnable {&#10;        private final String nombre;&#10;        &#10;        public Consumidor(String nombre) {&#10;            this.nombre = nombre;&#10;        }&#10;        &#10;        @Override&#10;        public void run() {&#10;            try {&#10;                while (!Thread.currentThread().isInterrupted()) {&#10;                    System.out.println(&quot; &quot; + nombre + &quot; esperando elemento... (Tamaño cola: &quot; + cola.size() + &quot;)&quot;);&#10;                    &#10;                    // take() bloquea si la cola está vacía&#10;                    String mensaje = cola.take();&#10;                    &#10;                    System.out.println(&quot;✅ &quot; + nombre + &quot; consumió: &quot; + mensaje + &#10;                                     &quot; (Tamaño cola: &quot; + cola.size() + &quot;)&quot;);&#10;                    &#10;                    // Simular procesamiento&#10;                    Thread.sleep(1500);&#10;                }&#10;            } catch (InterruptedException e) {&#10;                System.out.println(&quot; &quot; + nombre + &quot; interrumpido&quot;);&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/blocking_queue/MetodosBlockingQueue.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/blocking_queue/MetodosBlockingQueue.java" />
              <option name="updatedContent" value="package blocking_queue;&#10;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Demostración de los diferentes métodos de BlockingQueue&#10; */&#10;public class MetodosBlockingQueue {&#10;    &#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;=== MÉTODOS DE BLOCKING QUEUE ===\n&quot;);&#10;        &#10;        // Cola con capacidad de 3 elementos&#10;        BlockingQueue&lt;String&gt; cola = new ArrayBlockingQueue&lt;&gt;(3);&#10;        &#10;        demostrarMetodosInsercion(cola);&#10;        System.out.println();&#10;        demostrarMetodosExtraccion(cola);&#10;        System.out.println();&#10;        demostrarMetodosConTimeout(cola);&#10;    }&#10;    &#10;    /**&#10;     * Demuestra los diferentes métodos para insertar elementos&#10;     */&#10;    private static void demostrarMetodosInsercion(BlockingQueue&lt;String&gt; cola) {&#10;        System.out.println(&quot;--- MÉTODOS DE INSERCIÓN ---&quot;);&#10;        &#10;        try {&#10;            // 1. add() - Lanza excepción si la cola está llena&#10;            System.out.println(&quot;1. add(): &quot; + cola.add(&quot;Elemento1&quot;)); // true&#10;            System.out.println(&quot;   Tamaño: &quot; + cola.size());&#10;            &#10;            // 2. offer() - Retorna false si la cola está llena&#10;            System.out.println(&quot;2. offer(): &quot; + cola.offer(&quot;Elemento2&quot;)); // true&#10;            System.out.println(&quot;   Tamaño: &quot; + cola.size());&#10;            &#10;            // 3. put() - Bloquea si la cola está llena&#10;            cola.put(&quot;Elemento3&quot;);&#10;            System.out.println(&quot;3. put(): Elemento3 añadido&quot;);&#10;            System.out.println(&quot;   Tamaño: &quot; + cola.size() + &quot; (COLA LLENA)&quot;);&#10;            &#10;            // Ahora la cola está llena (capacidad 3)&#10;            &#10;            // 4. Intentar add() con cola llena&#10;            try {&#10;                cola.add(&quot;Elemento4&quot;);&#10;            } catch (IllegalStateException e) {&#10;                System.out.println(&quot;4. add() con cola llena: &quot; + e.getClass().getSimpleName());&#10;            }&#10;            &#10;            // 5. Intentar offer() con cola llena&#10;            System.out.println(&quot;5. offer() con cola llena: &quot; + cola.offer(&quot;Elemento4&quot;)); // false&#10;            &#10;            // 6. offer() con timeout&#10;            System.out.println(&quot;6. offer() con timeout de 1 segundo...&quot;);&#10;            long inicio = System.currentTimeMillis();&#10;            boolean resultado = cola.offer(&quot;Elemento4&quot;, 1, TimeUnit.SECONDS);&#10;            long tiempo = System.currentTimeMillis() - inicio;&#10;            System.out.println(&quot;   Resultado: &quot; + resultado + &quot; (Tiempo: &quot; + tiempo + &quot;ms)&quot;);&#10;            &#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Demuestra los diferentes métodos para extraer elementos&#10;     */&#10;    private static void demostrarMetodosExtraccion(BlockingQueue&lt;String&gt; cola) {&#10;        System.out.println(&quot;--- MÉTODOS DE EXTRACCIÓN ---&quot;);&#10;        &#10;        try {&#10;            // 1. remove() - Lanza excepción si la cola está vacía&#10;            System.out.println(&quot;1. remove(): &quot; + cola.remove());&#10;            System.out.println(&quot;   Tamaño: &quot; + cola.size());&#10;            &#10;            // 2. poll() - Retorna null si la cola está vacía&#10;            System.out.println(&quot;2. poll(): &quot; + cola.poll());&#10;            System.out.println(&quot;   Tamaño: &quot; + cola.size());&#10;            &#10;            // 3. take() - Bloquea si la cola está vacía&#10;            System.out.println(&quot;3. take(): &quot; + cola.take());&#10;            System.out.println(&quot;   Tamaño: &quot; + cola.size() + &quot; (COLA VACÍA)&quot;);&#10;            &#10;            // Ahora la cola está vacía&#10;            &#10;            // 4. Intentar remove() con cola vacía&#10;            try {&#10;                cola.remove();&#10;            } catch (Exception e) {&#10;                System.out.println(&quot;4. remove() con cola vacía: &quot; + e.getClass().getSimpleName());&#10;            }&#10;            &#10;            // 5. Intentar poll() con cola vacía&#10;            System.out.println(&quot;5. poll() con cola vacía: &quot; + cola.poll()); // null&#10;            &#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Demuestra métodos con timeout&#10;     */&#10;    private static void demostrarMetodosConTimeout(BlockingQueue&lt;String&gt; cola) {&#10;        System.out.println(&quot;--- MÉTODOS CON TIMEOUT ---&quot;);&#10;        &#10;        try {&#10;            // poll() con timeout en cola vacía&#10;            System.out.println(&quot;1. poll() con timeout de 2 segundos en cola vacía...&quot;);&#10;            long inicio = System.currentTimeMillis();&#10;            String resultado = cola.poll(2, TimeUnit.SECONDS);&#10;            long tiempo = System.currentTimeMillis() - inicio;&#10;            System.out.println(&quot;   Resultado: &quot; + resultado + &quot; (Tiempo: &quot; + tiempo + &quot;ms)&quot;);&#10;            &#10;            // Añadir un elemento para la siguiente prueba&#10;            cola.offer(&quot;ElementoTest&quot;);&#10;            &#10;            // poll() con timeout en cola con elementos&#10;            System.out.println(&quot;2. poll() con timeout en cola con elementos:&quot;);&#10;            System.out.println(&quot;   Resultado: &quot; + cola.poll(1, TimeUnit.SECONDS));&#10;            &#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/blocking_queue/RestauranteBlockingQueue.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/blocking_queue/RestauranteBlockingQueue.java" />
              <option name="updatedContent" value="package blocking_queue;&#10;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.Random;&#10;&#10;/**&#10; * Ejemplo práctico: Sistema de Procesamiento de Pedidos&#10; * Simula un restaurante donde los cocineros (productores) preparan pedidos&#10; * y los camareros (consumidores) los sirven a las mesas&#10; */&#10;public class RestauranteBlockingQueue {&#10;    &#10;    // Cola de pedidos listos para servir (capacidad limitada)&#10;    private static final BlockingQueue&lt;Pedido&gt; colapedidos = new ArrayBlockingQueue&lt;&gt;(10);&#10;    private static final Random random = new Random();&#10;    &#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;️  === RESTAURANTE CON BLOCKING QUEUE ===\n&quot;);&#10;        &#10;        // Crear cocineros (productores)&#10;        Thread cocinero1 = new Thread(new Cocinero(&quot;Chef Mario&quot;), &quot;Chef-Mario&quot;);&#10;        Thread cocinero2 = new Thread(new Cocinero(&quot;Chef Luigi&quot;), &quot;Chef-Luigi&quot;);&#10;        &#10;        // Crear camareros (consumidores)&#10;        Thread camarero1 = new Thread(new Camarero(&quot;Ana&quot;), &quot;Camarero-Ana&quot;);&#10;        Thread camarero2 = new Thread(new Camarero(&quot;Carlos&quot;), &quot;Camarero-Carlos&quot;);&#10;        Thread camarero3 = new Thread(new Camarero(&quot;María&quot;), &quot;Camarero-María&quot;);&#10;        &#10;        // Iniciar todos los hilos&#10;        cocinero1.start();&#10;        cocinero2.start();&#10;        camarero1.start();&#10;        camarero2.start();&#10;        camarero3.start();&#10;        &#10;        try {&#10;            // Simular 15 segundos de trabajo&#10;            Thread.sleep(15000);&#10;            &#10;            // Parar todos los hilos&#10;            cocinero1.interrupt();&#10;            cocinero2.interrupt();&#10;            camarero1.interrupt();&#10;            camarero2.interrupt();&#10;            camarero3.interrupt();&#10;            &#10;            System.out.println(&quot;\n Restaurante cerrado. Pedidos pendientes: &quot; + colapedidos.size());&#10;            &#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Clase que representa un pedido&#10;     */&#10;    static class Pedido {&#10;        private final int numero;&#10;        private final String plato;&#10;        private final String cocinero;&#10;        private final long tiempoCreacion;&#10;        &#10;        public Pedido(int numero, String plato, String cocinero) {&#10;            this.numero = numero;&#10;            this.plato = plato;&#10;            this.cocinero = cocinero;&#10;            this.tiempoCreacion = System.currentTimeMillis();&#10;        }&#10;        &#10;        public int getNumero() { return numero; }&#10;        public String getPlato() { return plato; }&#10;        public String getCocinero() { return cocinero; }&#10;        &#10;        public long getTiempoEspera() {&#10;            return System.currentTimeMillis() - tiempoCreacion;&#10;        }&#10;        &#10;        @Override&#10;        public String toString() {&#10;            return &quot;Pedido #&quot; + numero + &quot; (&quot; + plato + &quot;) por &quot; + cocinero;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Cocinero - Produce pedidos (Productor)&#10;     */&#10;    static class Cocinero implements Runnable {&#10;        private final String nombre;&#10;        private final String[] platos = {&quot;Pizza Margarita&quot;, &quot;Pasta Carbonara&quot;, &quot;Ensalada César&quot;, &#10;                                        &quot;Hamburguesa&quot;, &quot;Sopa del día&quot;, &quot;Paella&quot;};&#10;        private int numeroPedido = 1;&#10;        &#10;        public Cocinero(String nombre) {&#10;            this.nombre = nombre;&#10;        }&#10;        &#10;        @Override&#10;        public void run() {&#10;            try {&#10;                while (!Thread.currentThread().isInterrupted()) {&#10;                    // Tiempo de preparación (1-4 segundos)&#10;                    int tiempoPreparacion = 1000 + random.nextInt(3000);&#10;                    Thread.sleep(tiempoPreparacion);&#10;                    &#10;                    // Crear pedido&#10;                    String platoSeleccionado = platos[random.nextInt(platos.length)];&#10;                    Pedido pedido = new Pedido(numeroPedido++, platoSeleccionado, nombre);&#10;                    &#10;                    System.out.println(&quot;‍ &quot; + nombre + &quot; preparó: &quot; + pedido + &#10;                                     &quot; (Cola: &quot; + colapedidos.size() + &quot;/10)&quot;);&#10;                    &#10;                    // Intentar añadir a la cola con timeout de 5 segundos&#10;                    boolean añadido = colapedidos.offer(pedido, 5, TimeUnit.SECONDS);&#10;                    &#10;                    if (añadido) {&#10;                        System.out.println(&quot;✅ &quot; + pedido + &quot; listo para servir&quot;);&#10;                    } else {&#10;                        System.out.println(&quot;⚠️  Cola llena! &quot; + pedido + &quot; se ha perdido&quot;);&#10;                    }&#10;                }&#10;            } catch (InterruptedException e) {&#10;                System.out.println(&quot; &quot; + nombre + &quot; ha terminado su turno&quot;);&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Camarero - Sirve pedidos (Consumidor)&#10;     */&#10;    static class Camarero implements Runnable {&#10;        private final String nombre;&#10;        private int pedidosServidos = 0;&#10;        &#10;        public Camarero(String nombre) {&#10;            this.nombre = nombre;&#10;        }&#10;        &#10;        @Override&#10;        public void run() {&#10;            try {&#10;                while (!Thread.currentThread().isInterrupted()) {&#10;                    System.out.println(&quot; &quot; + nombre + &quot; buscando pedidos... (Cola: &quot; + colapedidos.size() + &quot;)&quot;);&#10;                    &#10;                    // Esperar por un pedido (con timeout de 3 segundos)&#10;                    Pedido pedido = colapedidos.poll(3, TimeUnit.SECONDS);&#10;                    &#10;                    if (pedido != null) {&#10;                        pedidosServidos++;&#10;                        long tiempoEspera = pedido.getTiempoEspera();&#10;                        &#10;                        System.out.println(&quot;️  &quot; + nombre + &quot; sirvió: &quot; + pedido + &#10;                                         &quot; (Tiempo espera: &quot; + tiempoEspera + &quot;ms)&quot;);&#10;                        &#10;                        // Tiempo para servir (1-2 segundos)&#10;                        Thread.sleep(1000 + random.nextInt(1000));&#10;                        &#10;                        System.out.println(&quot;✨ &quot; + nombre + &quot; completó el servicio del &quot; + pedido);&#10;                        &#10;                    } else {&#10;                        System.out.println(&quot; &quot; + nombre + &quot; esperando... no hay pedidos&quot;);&#10;                    }&#10;                }&#10;            } catch (InterruptedException e) {&#10;                System.out.println(&quot; &quot; + nombre + &quot; terminó (Pedidos servidos: &quot; + pedidosServidos + &quot;)&quot;);&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>